<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>3 Pedals</title>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(ellipse at center, #081028 0%, #000814 60%); }
        canvas { display:block }
        #info {
            position: absolute;
            top: 10px;
            right: 12px;
            color: #08f7fe;
            font-family: "Orbitron", monospace;
            font-size: 18px;
            background: rgba(2,6,16,0.35);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(8,247,254,0.12);
            box-shadow: 0 0 24px rgba(8,247,254,0.06);
            text-shadow: 0 0 6px rgba(0,0,0,0.8);
        }
        #startMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
            color: #00ffd5;
            font-size: 28px;
            font-family: "Orbitron", monospace;
            text-align:center;
            text-shadow: 0 0 12px rgba(0,255,213,0.5);
            background: rgba(0,0,0,0.35);
            padding: 18px 28px;
            border-radius: 12px;
            cursor: wait;
            border: 1px solid rgba(0,255,213,0.12);
        }
        #hud {
            position: absolute;
            left: 12px;
            bottom: 12px;
            color: #ffd600;
            font-family: "Orbitron", monospace;
            font-size: 14px;
            background: rgba(2,2,6,0.45);
            padding: 10px;
            border-radius: 8px;
        }
        #crosshair {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 40px;
            height: 40px;
            transform: translate(-50%,-50%);
            pointer-events: none;
            mix-blend-mode: screen;
        }
        #crosshair:before, #crosshair:after {
            content: "";
            position: absolute;
            left: 50%; top: 50%;
            width: 2px; height: 18px;
            background: linear-gradient(#00ffd5, transparent);
            transform-origin: center;
        }
        #crosshair:before { transform: translate(-50%,-50%) rotate(0deg); }
        #crosshair:after  { transform: translate(-50%,-50%) rotate(90deg); }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="info">Speed: 0 km/h</div>
    <div id="startMessage">LOADING...</div>
    <div id="hud">MODE: AUTOPILOT OFF</div>
    <div id="crosshair"></div>
    <canvas id="gameCanvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.161.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.161.0/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js';
    // --- IMPORT THE GLTF LOADER ---
    import { GLTFLoader } from 'https://unpkg.com/three@0.161.0/examples/jsm/loaders/GLTFLoader.js';

    // --- BASIC SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.outputEncoding = THREE.sRGBEncoding;

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000814, 0.0025);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 4, 10);

    // Postprocessing (bloom)
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.9, 0.6, 0.1);
    bloom.threshold = 0.1;
    bloom.strength = 1.4;
    bloom.radius = 0.8;
    composer.addPass(bloom);

    const infoElement = document.getElementById('info');
    const startMessage = document.getElementById('startMessage');
    const hud = document.getElementById('hud');
    let gameStarted = false;

    // --- LIGHTING ---
    const ambient = new THREE.AmbientLight(0x88bbff, 0.25);
    scene.add(ambient);

    const keyLight = new THREE.DirectionalLight(0xfff8f0, 0.7);
    keyLight.position.set(10, 20, 10);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.set(2048, 2048);
    scene.add(keyLight);

    // rim neon lights
    const neonLeft = new THREE.PointLight(0x00ffd5, 0.9, 30, 2);
    neonLeft.position.set(-6, 2, 0);
    const neonRight = new THREE.PointLight(0xff00d0, 0.9, 30, 2);
    neonRight.position.set(6, 2, 0);
    scene.add(neonLeft, neonRight);

    // --- SKY / STARS ---
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 1500;
    const starPos = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
        const r = 200 + Math.random() * 800;
        const theta = Math.random() * Math.PI * 2;
        const phi = (Math.random() - 0.5) * Math.PI;
        starPos[i*3] = Math.cos(theta) * Math.cos(phi) * r;
        starPos[i*3+1] = Math.sin(phi) * r * 0.6 + 40;
        starPos[i*3+2] = Math.sin(theta) * Math.cos(phi) * r;
    }
    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const stars = new THREE.Points(starGeometry, new THREE.PointsMaterial({ color: 0xffffff, size: 0.7, transparent: true, opacity: 0.9 }));
    scene.add(stars);

    // --- GROUND / ROAD (neon) ---
    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(60, 4000),
        new THREE.MeshStandardMaterial({ color: 0x071022, metalness: 0.2, roughness: 0.6 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    ground.position.y = 0;
    scene.add(ground);

    // Road strip — wide neon ribbon in the center
    const road = new THREE.Mesh(
        new THREE.PlaneGeometry(12, 4000, 1, 1),
        new THREE.MeshStandardMaterial({ color: 0x0b0f2a, emissive: 0x001a3d, emissiveIntensity: 0.6, roughness: 0.3 })
    );
    road.rotation.x = -Math.PI/2;
    road.position.y = 0.01;
    scene.add(road);

    // Neon lane divider segments (glow with bloom)
    const laneSegments = [];
    for (let i = 0; i < 200; i++) {
        const seg = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.02, 6),
            new THREE.MeshStandardMaterial({ color: 0x00ffd5, emissive: 0x00ffd5, emissiveIntensity: 1.4 })
        );
        seg.position.z = -i * 20 + 250;
        seg.position.y = 0.02;
        seg.receiveShadow = true;
        laneSegments.push(seg);
        scene.add(seg);
    }

    // Side neon lines
    const sideLines = [];
    for (let s = -1; s <= 1; s += 2) {
        for (let i = 0; i < 200; i++) {
            const sl = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.02, 12),
                new THREE.MeshStandardMaterial({ color: s < 0 ? 0xff00d0 : 0x00b3ff, emissive: s < 0 ? 0xff00d0 : 0x00b3ff, emissiveIntensity: 1.0 })
            );
            sl.position.x = s * 6.5;
            sl.position.z = -i * 20 + Math.random()*6;
            sl.position.y = 0.02;
            sideLines.push(sl);
            scene.add(sl);
        }
    }

    // --- PLAYER CAR (futuristic hover) ---
    const car = new THREE.Group();
    scene.add(car);

    // --- NEW: Load the custom GLB model ---
    const loader = new GLTFLoader();
    loader.load(
        // URL to your model
        'https://bangorinas-play.github.io/PlayGameAssets/Car.glb',
        // Function to run when the model is loaded
        function (gltf) {
            const model = gltf.scene;
            
            // Adjust the model's properties
            model.scale.set(0, 0, 0);
            model.rotation.y = Math.PI; // Rotate 180 degrees to face forward
            model.position.y = 0;
            model.position.z = -1;
            
            // Make all meshes in the model cast a shadow
            model.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                }
            });
            
            // Add the loaded model to the main 'car' group
            car.add(model);
            
            // Update start message now that loading is complete
            startMessage.innerText = 'CLICK TO START — NEON RUN';
            startMessage.style.cursor = 'pointer';
        },
        // Optional: Progress function (not used here)
        undefined,
        // Function to run if an error occurs
        function (error) {
            console.error('An error happened while loading the car model.', error);
            startMessage.innerText = 'ERROR LOADING MODEL';
        }
    );

    // camera follow offset
    const camOffset = new THREE.Vector3(0, 3.4, 8);

    // --- OBSTACLES: hovering drones (futuristic) ---
    const obstacles = [];
    const obstacleCount = 12;
    for (let i = 0; i < obstacleCount; i++) {
        const drone = new THREE.Group();
        const core = new THREE.Mesh(new THREE.SphereGeometry(0.6, 12, 12), new THREE.MeshStandardMaterial({ color: 0xff00d0, emissive: 0xff4466, emissiveIntensity: 1.2 }));
        core.castShadow = true;
        drone.add(core);

        const wing = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.08, 0.08), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.6 }));
        wing.position.set(0, 0, 0.9);
        drone.add(wing);

        drone.position.x = (Math.random() - 0.5) * 10;
        drone.position.z = -Math.random() * 800 - 50;
        drone.position.y = 1.6 + Math.random() * 1.6;
        drone.userData = { bobOffset: Math.random() * Math.PI * 2, speed: 0.6 + Math.random() * 0.8 };
        obstacles.push(drone);
        scene.add(drone);
    }

    // --- SPEED LINES (particles) ---
    const slCount = 600;
    const slGeom = new THREE.BufferGeometry();
    const slPos = new Float32Array(slCount*3);
    const slVel = new Float32Array(slCount);
    for (let i=0;i<slCount;i++){
        slPos[i*3] = (Math.random()-0.5)*8;
        slPos[i*3+1] = (Math.random()-0.2)*2 + 1.8;
        slPos[i*3+2] = -Math.random()*60;
        slVel[i] = 0.6 + Math.random()*1.6;
    }
    slGeom.setAttribute('position', new THREE.BufferAttribute(slPos, 3));
    slGeom.setAttribute('vel', new THREE.BufferAttribute(slVel, 1));
    const slMat = new THREE.PointsMaterial({ color: 0x00ffd5, size: 0.25, transparent: true, opacity: 0.9 });
    const speedLines = new THREE.Points(slGeom, slMat);
    scene.add(speedLines);

    // --- GAME LOGIC ---
    let speed = 0;
    const maxSpeed = 4;
    const acceleration = 0.06;
    const friction = 0.02;
    const turnSpeed = 0.035;
    const keys = { w:false,a:false,s:false,d:false, arrowup:false,arrowdown:false,arrowleft:false,arrowright:false };

    window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
    window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

    function resetObstacle(o) {
        o.position.x = (Math.random() - 0.5) * 10;
        o.position.z = car.position.z - 400 - Math.random() * 600;
        o.position.y = 1.6 + Math.random() * 2.4;
    }

    camera.lookAt(car.position);

    function animate(t){
        requestAnimationFrame(animate);

        if (!gameStarted) {
            // idle hover animation for car and small star twinkle
            car.rotation.y += 0.0006;
            stars.rotation.y += 0.0004;
            // Use composer for idle screen to keep bloom effect
            composer.render();
            return;
        }

        // handle input
        if (keys.w || keys.arrowup) speed = Math.min(maxSpeed, speed + acceleration);
        if (keys.s || keys.arrowdown) speed = Math.max(-maxSpeed/2, speed - acceleration*1.2);
        if (!(keys.w || keys.s || keys.arrowup || keys.arrowdown)) {
            if (speed > 0) speed = Math.max(0, speed - friction);
            if (speed < 0) speed = Math.min(0, speed + friction);
        }

        // turning scales with speed
        let turn = 0;
        if (keys.a || keys.arrowleft) turn = 1;
        if (keys.d || keys.arrowright) turn = -1;
        car.rotation.y += turn * turnSpeed * (Math.abs(speed)/maxSpeed);

        // movement
        car.position.z -= Math.cos(car.rotation.y) * speed;
        car.position.x -= Math.sin(car.rotation.y) * speed;

        // boundaries
        if (Math.abs(car.position.x) > 18) {
            car.position.x = Math.sign(car.position.x) * 18;
            speed = 0;
        }

        // camera follow
        const offset = camOffset.clone().applyQuaternion(car.quaternion);
        camera.position.copy(car.position).add(offset);
        camera.lookAt(car.position);

        // update lane segments / side lines recycle
        laneSegments.forEach(s => {
            if (s.position.z > camera.position.z + 20) s.position.z -= 4000;
        });
        sideLines.forEach(s => {
            if (s.position.z > camera.position.z + 30) s.position.z -= 4000;
        });

        // obstacles bob and move closer to player and recycle
        obstacles.forEach(o => {
            o.position.z += (speed * 0.5) * 0.8; // relative movement
            o.position.y = 1.6 + Math.sin((t/500) * o.userData.speed + o.userData.bobOffset) * 0.6;
            o.rotation.y += 0.01 * o.userData.speed;
            if (o.position.z > camera.position.z + 20) resetObstacle(o);
        });

        // speed lines update (parallax behind car)
        {
            const posAttr = speedLines.geometry.attributes.position;
            const velAttr = speedLines.geometry.attributes.vel;
            for (let i=0;i<slCount;i++){
                let z = posAttr.array[i*3+2];
                z += (velAttr.array[i] * (speed*1.6 + 0.5));
                if (z > 6) {
                    posAttr.array[i*3] = (Math.random()-0.5)*8;
                    posAttr.array[i*3+1] = (Math.random()-0.2)*2 + 1.8;
                    posAttr.array[i*3+2] = -Math.random()*80 - 20;
                } else {
                    posAttr.array[i*3+2] = z;
                }
            }
            posAttr.needsUpdate = true;
        }

        // collision check (AABB)
        const carBox = new THREE.Box3().setFromObject(car);
        obstacles.forEach(o => {
            const box = new THREE.Box3().setFromObject(o);
            if (carBox.intersectsBox(box)) {
                // collision reaction
                speed = Math.max(0, speed - 2.2);
                // flash HUD
                hud.style.background = 'rgba(255,0,80,0.85)';
                setTimeout(()=> hud.style.background = 'rgba(2,2,6,0.45)', 120);
                resetObstacle(o);
            }
        });

        // UI update
        infoElement.innerText = `Speed: ${Math.round(Math.abs(speed) * 100)} km/h`;
        hud.innerText = `MODE: MANUAL\nX: ${car.position.x.toFixed(1)}  Z: ${Math.round(-car.position.z)}`;

        // subtle star parallax
        stars.rotation.y += (speed / maxSpeed) * 0.004;

        // renderer + bloom
        composer.render();
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });

    startMessage.addEventListener('click', () => {
        // Only allow starting if the inner text is not 'LOADING...'
        if (startMessage.innerText.startsWith('CLICK')) {
            gameStarted = true;
            startMessage.style.display = 'none';
        }
    });

    // start loop
    animate();
    </script>
</body>
</html>