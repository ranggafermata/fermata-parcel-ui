<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UFO Run</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #0c0a18;
            background-image:
                radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 40px),
                radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 30px),
                radial-gradient(white, rgba(255,255,255,.1) 2px, transparent 40px),
                radial-gradient(rgba(255,255,255,.4), rgba(255,255,255,.1) 2px, transparent 30px);
            background-size: 550px 550px, 350px 350px, 250px 250px, 150px 150px;
            background-position: 0 0, 40px 60px, 130px 270px, 70px 100px;
            animation: stars 120s linear infinite;
        }

        @keyframes stars {
            from { background-position: 0 0, 40px 60px, 130px 270px, 70px 100px; }
            to { background-position: 550px 550px, 390px 410px, 380px 520px, 220px 350px; }
        }

        #gameCanvas {
            background-color: rgba(0, 0, 0, 0.2);
            box-shadow: 0 0 20px rgba(173, 216, 230, 0.5);
            border: 2px solid lightblue;
            border-radius: 15px;
            cursor: pointer;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen text-white overflow-hidden p-4">

    <div class="w-full max-w-4xl mx-auto text-center">
        <h1 class="text-4xl md:text-5xl mb-2 text-cyan-300 drop-shadow-[0_0_8px_rgba(100,200,255,0.8)]">UFO RUN</h1>
        <p class="text-sm md:text-base mb-4 text-gray-300">Press <span class="text-yellow-300">SPACE</span> or <span class="text-yellow-300">TAP</span> to fly!</p>
        
        <div class="relative inline-block">
             <canvas id="gameCanvas" width="800" height="400"></canvas>
             <div id="ui-container" class="absolute inset-0 flex flex-col items-center justify-center text-center p-4">
                 <p id="score" class="absolute top-4 right-4 text-2xl text-white">SCORE: 0</p>
                 <div id="startScreen" class="flex flex-col items-center justify-center">
                    <h2 class="text-3xl mb-4 text-yellow-300">Press Space to Start</h2>
                 </div>
                 <div id="gameOverScreen" class="hidden flex-col items-center justify-center bg-black bg-opacity-70 rounded-lg p-8">
                     <h2 class="text-4xl text-red-500 mb-2">GAME OVER</h2>
                     <p id="finalScore" class="text-2xl text-white mb-6"></p>
                     <button id="restartButton" class="px-6 py-3 bg-cyan-500 text-black rounded-lg text-xl hover:bg-cyan-400 transition-colors shadow-[0_0_15px_rgba(0,255,255,0.7)]">RESTART</button>
                 </div>
             </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // UI Elements
        const scoreElement = document.getElementById('score');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreElement = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        
        // Game Constants
        const UFO_WIDTH = 60;
        const UFO_HEIGHT = 30;
        const GRAVITY = 0.5;
        const LIFT = -8;
        const GROUND_HEIGHT = 20;

        // Game State
        let ufoY, ufoVelocityY, score, gameSpeed, obstacles, isGameOver, gameStarted;

        // UFO Drawing Function
        function drawUfo(y) {
            ctx.save();
            ctx.translate(canvas.width / 4, y);
            
            // UFO Body
            ctx.fillStyle = '#c0c0c0'; // Silver
            ctx.beginPath();
            ctx.moveTo(0, UFO_HEIGHT / 2);
            ctx.bezierCurveTo(UFO_WIDTH / 4, -UFO_HEIGHT / 2, 3 * UFO_WIDTH / 4, -UFO_HEIGHT / 2, UFO_WIDTH, UFO_HEIGHT / 2);
            ctx.fill();

            // UFO Cockpit
            ctx.fillStyle = '#87ceeb'; // Sky Blue
            ctx.beginPath();
            ctx.arc(UFO_WIDTH / 2, 0, UFO_WIDTH / 4, Math.PI, 2 * Math.PI);
            ctx.fill();

            // UFO Light Beam (subtle animation)
            const beamFlicker = Math.sin(Date.now() / 100) * 0.1 + 0.9;
            ctx.fillStyle = `rgba(255, 255, 0, ${0.4 * beamFlicker})`; // Yellowish beam
            ctx.beginPath();
            ctx.moveTo(UFO_WIDTH * 0.3, UFO_HEIGHT / 2);
            ctx.lineTo(UFO_WIDTH * 0.7, UFO_HEIGHT / 2);
            ctx.lineTo(UFO_WIDTH * 0.8, UFO_HEIGHT * 1.2);
            ctx.lineTo(UFO_WIDTH * 0.2, UFO_HEIGHT * 1.2);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        }

        // Obstacle Drawing Function
        function drawObstacle(obstacle) {
            ctx.fillStyle = '#b87333'; // Copper color for asteroid
            ctx.save();
            ctx.translate(obstacle.x + obstacle.width / 2, obstacle.y + obstacle.height / 2);
            ctx.rotate(obstacle.rotation);
            ctx.beginPath();
            // Irregular asteroid shape
            ctx.moveTo(0, -obstacle.height / 2);
            ctx.lineTo(obstacle.width / 2, -obstacle.height / 4);
            ctx.lineTo(obstacle.width / 2, obstacle.height / 4);
            ctx.lineTo(0, obstacle.height / 2);
            ctx.lineTo(-obstacle.width / 2, obstacle.height / 4);
            ctx.lineTo(-obstacle.width / 2, -obstacle.height / 4);
            ctx.closePath();
            ctx.fill();
            
            // Craters
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.arc(obstacle.width * 0.1, -obstacle.height * 0.1, obstacle.width/8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-obstacle.width * 0.2, obstacle.height * 0.2, obstacle.width/10, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Ground Drawing Function
        function drawGround() {
            ctx.fillStyle = '#3a2d27'; // Dark brown moon surface
            ctx.fillRect(0, canvas.height - GROUND_HEIGHT, canvas.width, GROUND_HEIGHT);
            
            // Craters on the ground
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.arc(100, canvas.height - GROUND_HEIGHT/2, 20, 0, Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(450, canvas.height - GROUND_HEIGHT, 30, 0, Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(700, canvas.height - GROUND_HEIGHT/3, 15, 0, Math.PI);
            ctx.fill();
        }

        function resetGame() {
            ufoY = canvas.height / 2;
            ufoVelocityY = 0;
            score = 0;
            gameSpeed = 4;
            obstacles = [];
            isGameOver = false;
            gameStarted = false;

            gameOverScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            scoreElement.innerText = 'SCORE: 0';
        }

        function spawnObstacle() {
            const isTopObstacle = Math.random() > 0.5;
            const height = Math.random() * (canvas.height / 3) + 50;
            const width = Math.random() * 30 + 40;
            
            let y;
            if (isTopObstacle) {
                 y = 0;
            } else {
                 y = canvas.height - height - GROUND_HEIGHT;
            }

            obstacles.push({
                x: canvas.width,
                y: y,
                width: width,
                height: height,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.02
            });
        }
        
        let obstacleSpawnTimer = 0;
        function update() {
            if (isGameOver) return;
            
            if (!gameStarted) {
                // Initial animation before game starts
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ufoY = canvas.height / 2 + Math.sin(Date.now() / 200) * 10;
                drawUfo(ufoY);
                drawGround();
                requestAnimationFrame(update);
                return;
            }

            // Game Logic
            ufoVelocityY += GRAVITY;
            ufoY += ufoVelocityY;

            // Collision with top/bottom
            if (ufoY > canvas.height - UFO_HEIGHT - GROUND_HEIGHT) {
                ufoY = canvas.height - UFO_HEIGHT - GROUND_HEIGHT;
                ufoVelocityY = 0;
            }
             if (ufoY < 0) {
                ufoY = 0;
                ufoVelocityY = 0;
            }

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw Ground
            drawGround();

            // Draw and update obstacles
            obstacleSpawnTimer--;
            if (obstacleSpawnTimer <= 0) {
                spawnObstacle();
                // Randomize spawn time for next obstacle
                obstacleSpawnTimer = Math.random() * 50 + (150 - gameSpeed * 5);
            }
            
            let passedObstacle = false;
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.x -= gameSpeed;
                obs.rotation += obs.rotationSpeed;
                drawObstacle(obs);
                
                // Collision Detection
                const ufoX = canvas.width / 4;
                if (ufoX < obs.x + obs.width &&
                    ufoX + UFO_WIDTH > obs.x &&
                    ufoY < obs.y + obs.height &&
                    ufoY + UFO_HEIGHT > obs.y) {
                    endGame();
                }

                // Check if UFO passed the obstacle
                if (obs.x + obs.width < ufoX && !obs.passed) {
                    obs.passed = true;
                    passedObstacle = true;
                }
                
                // Remove off-screen obstacles
                if (obs.x + obs.width < 0) {
                    obstacles.splice(i, 1);
                }
            }
            
            if(passedObstacle) {
                score++;
                scoreElement.innerText = 'SCORE: ' + score;
                // Increase speed every 5 points
                if (score % 5 === 0) {
                    gameSpeed += 0.2;
                }
            }
            
            // Draw UFO
            drawUfo(ufoY);
            
            requestAnimationFrame(update);
        }

        function endGame() {
            isGameOver = true;
            finalScoreElement.innerText = 'FINAL SCORE: ' + score;
            gameOverScreen.classList.remove('hidden');
        }

        function handleInput() {
            if (isGameOver) return;

            if (!gameStarted) {
                gameStarted = true;
                startScreen.classList.add('hidden');
            }
            ufoVelocityY = LIFT;
        }

        // Event Listeners
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault(); // Prevent page from scrolling
                handleInput();
            }
        });
        
        canvas.addEventListener('mousedown', handleInput);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInput();
        });

        restartButton.addEventListener('click', () => {
            resetGame();
            requestAnimationFrame(update);
        });
        
        // Initial setup
        window.onload = () => {
             // Make canvas responsive
            const container = canvas.parentElement;
            function resizeCanvas() {
                const aspectRatio = 800 / 400;
                let newWidth = container.clientWidth;
                let newHeight = newWidth / aspectRatio;
                if (newHeight > window.innerHeight * 0.7) {
                    newHeight = window.innerHeight * 0.7;
                    newWidth = newHeight * aspectRatio;
                }
                canvas.style.width = `${newWidth}px`;
                canvas.style.height = `${newHeight}px`;
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            resetGame();
            update();
        };

    </script>
</body>
</html>
